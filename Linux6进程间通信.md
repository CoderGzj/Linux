# IPC 进程间通信
虚拟CPU和虚拟内存的引入保证了进程的一个重要特性就是隔离，一个进程在执行过程中总是认为自己占用了所有的CPU和内存

# **管道**
有名管道：在文件系统中存在一个管道文件
匿名管道：在文件系统中不存在 - 只用于父子进程间

## popen
FILE *popen(const char *command, const char *type);

"w" 父进程可写入FILE，子进程把自己的stdin重定向为管道；
"r" 父进程可读取FILE，子进程把自己的stdout重定向为管道

int pclose(FILE *stream);

![](img/2023-09-23-00-54-22.png)

## pipe 系统调用
使用系统调用 pipe 可以创建匿名管道，为了支持可移植性，管道是半双工的，所以一般同时使用两条管道来实现全双工通信。

除此以外，管道只使用于存在亲缘关系的进程之间进行通信。通常而言，在一个进程中可以创建一个管道，然后再利用fork 就可以实现进程间通信了。

int pipe(int pipefd[2]);

使用pipe 之前，需要首先创建一个大小为2的整型数组，用于存储文件描述符
pipefd[0]是读端，pipefd[1]是写端

如果要实现父子进程之间全双工通信，需要调用pipe 两次来创建两条管道

![](img/2023-09-23-16-14-07.png)

## FIFO
使用mkfifo 可以创建管道文件，
int mkfifo(const char *pathname, mode_t mode);

使用unlink 则可以删除所有文件包括管道文件。
int unlink(const char *path);

移动/重命名文件，使用rename 接口即可
int rename(const char *oldpath, const char *newpath);

使用link 接口可以给文件建立硬连接。
int link(const char *oldpath, const char *newpath);

# 共享内存
## 使用共享内存原因
* 为了提升进程间通信的效率，共享内存（也有翻译成共享存储）的方式就诞生了。
共享内存是效率最高的IPC

* 共享内存就允许两个或者多个进程共享一个给定的物理存储区域。当然为了实现共享，内核会专门维护一个用来存储共享内存信息的数据结构，这用不同的进程就可以通过共享内存进行通信了。
> $lsof
使用lsof命令可以列出所有进程所打开的文件
可以发现非常多进程都使用C标准库文件

## System V 版本的共享内存
* 内核使用一个非负整数键（key）来区分不同的共享内存区域（或者是信号量或消息队列）。服务端进程和客户端进程可以使用同一个键来定位共享内存段进行通信。

* 键可以手动指定，也可以使用接口ftok 生成。ftok 需要根据一个已存在的文件和一个项目ID（0～255的整数）来生成一个键。

key_t ftok(const char *pathname, int proj_id);

## 创建/获取共享内存
使用shmget 接口可以根据键来获取一个共享内存段。创建的共享内存段的所有字节会被初始化为0。

int shmget(key_t key, size_t size, int shmflg);

* key参数表示传入的键，可以是一个正数或者是宏IPC_PRIVATE。
* size表示共享内存的大小，其取值应当是页大小的整数倍。
* shmflg表示共享内存的属性，其最低9位表示各个用户对其的读/写/执行权限。
* shmget 的返回值表示共享内存段的描述符，以供后续使用。

使用shmat 接口根据一个指定描述来建立连接。

void *shmat(int shmid, const void *shmaddr, int shmflg);

shmaddr参数一般设置为空指针，表示在堆空间中自动分配区域映射共享内存段。shmflg表示权限（事实上这个权限是多余的），一般就是0。

![](img/2023-09-23-18-04-30.png)

## 使用共享内存进行进程间通信
共享内存可以在两个互不关联的进程之间进行通信，只需要彼此之间知道共享内存的键就好了。

## 两个进程同时对共享内存写入
共享内存可以实现多个进程同时对同一个数据进行访问和修改，这种并发的操作往往会造成预期外的错误。
这个多个进程同时写入造成结果出错误的情况被称为**竞态条件**。

## 解除共享内存映射
使用shmdt 可以解除堆空间到共享内存段的映射。具体的使用方法和free 差不多。
![](img/2023-09-28-23-48-23.png)

## 修改共享内存属性
使用shmctl 可以用于对共享内存段执行多种操作。根据cmd参数的不同，可以执行不同的操作：
- IPC_STAT可以用来获取存储共享内存段信息的数据结构；
- IPC_SET 可以用来修改共享内存段的所有者、所在组和权限;
- IPC_RMID 可以用来从内核删除共享内存段，当删除时，无论此时有多少进程映射到共享内存段，它都会被标记为待删除，一旦被标记以后，就无法再建立映射了。当最后一个映射解除时，共享内存段就真正被移除。

![](img/2023-09-29-10-23-19.png)

## 私有共享内存
使用shmget 接口时，如果参数key的取值是宏IPC_PRIVATE 。那么创建的共享内存段是私有的。
如果利用私有共享内存进行通信，那么进程之间必须存在亲缘关系。

## 虚拟地址和物理地址转换机制
### 地址分类
在x86架构中，地址分为3类：逻辑地址、线性地址和物理地址。
- 逻辑地址是使用在机器指令当中的地址，由段和偏移量组成。
- 线性地址就是虚拟地址，是代码中所使用的地址。
- 物理地址是内存芯片中用于访问物理内存的地址，是最底层的地址。

### 硬件分页机制
分页单元的主要作用就是把虚拟地址转换成物理地址。
虚拟地址空间和物理内存都被分成固定长度的页（常见的页大小是4096字节）。
在一个虚拟页中，虚拟地址是连续的，其映射的物理地址也是连续的（物理页，也叫页框）。在内核访问内存时，每次访问都是以一页为单位的。


# 信号量