# 1 进程池和线程池的设计思路
一个良好的架构需要满足许多侧面的要求，其中最基本的要求是可维护性和性能
![](img/2023-11-09-21-03-38.png)

池化的思路
申请了资源之后，用完毕不要马上回收，可以交给另外的事情复用
进程池/线程池设计思路：
1. 提前创建好若干进程
2. 每当有任务到来分配一个进程
3. 任务完成后归还进程
4. 整个进程池关闭的时候再销毁

问题
任务太多 -> 任务队列
事件 -> IO多路复用
事件驱动模型 event-driven

# 2 进程池的实现
![](img/2023-11-09-21-11-47.png)

## 2.1 父子进程创建
首先，我们先实现最基本的功能，使用一个父进程创建若干个子进程。

## 2.2 父进程处理网络连接
在创建完所有的子进程之后，父进程的下一个工作目标是准备接受客户端的TCP连接，这个工作和之前网络编程时的工作内容差不多，按照socket 、bind 和listen 的顺序执行系统调用即可。

## 2.3 本地套接字
父进程和子进程的地址空间是隔离的，如果两个进程之间需要进行通信，那就要选择一种合适的进程间通信的手段。
使用系统调用socketpair 可以在父子进程间利用socket 创建一个全双工的管道。除此以外，本地套接字可以在同一个操作系统的两个进程之间传递文件描述符。

int socketpair(int domain, int type, int protocol, int sv[2]);
* domain 必须填写AF_LOCAL。
* type 可以选择流式数据还是消息数据
* protocol 一般填0表示不需要任何额外的协议
* sv 这个参数和pipe 的参数一样，是一个长度为2的整型数据，用来存储管道两端的文件描述符（值得注意的是， sv[0] 和sv[1] 没有任何的区别）。

一般socketpair 之后会配合fork 函数一起使用，从而实现父子进程之间的通信。

## 2.4 父子进程共享文件描述符
除了传递一般的控制信息和文本信息（比如上传）以外，需要特别注意的是需要传递已连接套接字的文件描述符。
父进程会监听特定某个IP:PORT ，如果有某个客户端连接之后，子进程需要能够连上accept 得到的已连接套接字的文件描述符，这样子进程才能和客户端进行通信。这种文件描述符的传递不是简单地传输一个整型数字就行了，而是需要让父子进程共享一个套接字文件对象。
![](img/2023-11-09-21-32-07.png)

ssize_t sendmsg(int sockfd, const struct msghdr *msg, int flags);
ssize_t recvmsg(int sockfd, struct msghdr *msg, int flags);
使用sendmsg 和recvmsg 的时候附加一个消息头部，即一个struct msghdr 类型的结构体。
首先，需要将要传递的内容存储入msg_iov 当中，在这里需要注意的是，元素类型为struct iovec 的数组可以存储一组离散的消息，只需要将每个消息的起始地址和本消息的长度存入数组元素中即可。
接下来，需要将文件描述符的信息存入控制字段msg_control 中，这个我们需要存储一个地址值，该地址指向了一个struct cmsghdr 类型的控制信息。
为了传递文件描述符，需要将结构体中的cmsg_level 字段设置为SOL_SOCKET ，而 cmsg_type 字段需要设置为SCM_RIGHTS ，再将数据部分设置为文件描述符。这样，该文件描述符所指的文件对象就可以传递到另一个进程了。

![](img/2023-11-09-22-08-12.png)

![](img/2023-11-09-22-08-36.png)

# 3 文件的传输

# 4 进程池1.0

# 5 进程池的其他功能

# 6 线程池的实现